# Standard library imports
import os
import json
import re
import uuid
import time
import random
import string
import secrets
import traceback
from datetime import datetime, timedelta
from functools import wraps

# Third-party imports
from flask import Flask, request, jsonify, send_from_directory, make_response
from flask_cors import CORS, cross_origin
from flask_sqlalchemy import SQLAlchemy
from supabase import create_client, Client
from werkzeug.utils import secure_filename
from dotenv import load_dotenv
from supabase_client import get_supabase
import requests
import logging

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('app.log')
    ]
)
logger = logging.getLogger(__name__)


# Initialize SQLAlchemy
db = SQLAlchemy()

# Load environment variables
load_dotenv()

# Initialize Flask app
app = Flask(__name__)

# Configure database
app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL', 'sqlite:///career_courses.db')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# Initialize the database
db.init_app(app)

# Create tables
with app.app_context():
    try:
        from models.career_course import CareerCourse
        db.create_all()
        print("Database tables created successfully")
    except Exception as e:
        print(f"Error creating database tables: {e}")

# CORS will be configured later after ALLOWED_ORIGINS is defined

# Import blueprints - keep these at the top to detect circular imports early
# We'll import them properly after the app is created
auth_bp = None
admin_bp = None
students_bp = None
faculty_bp = None
internships_bp = None
admissions_bp = None
exams_bp = None
academics_bp = None
analytics_bp = None
attendance_bp = None
fees_bp = None
notifications_bp = None
resume_analytics_bp = None
upgraded_bp = None
student_dashboard_bp = None
crud_bp = None
career_roadmap_bp = None

# Initialize Supabase client
supabase = get_supabase()

try:
    import google.generativeai as genai  # type: ignore
    genai_available = True
except Exception:
    genai = None
    genai_available = False
    print('[STARTUP] google.generativeai not available - AI features disabled. Install "google-generativeai" to enable.')

def generate_secure_password(length=12):
    """Generate a random secure password with letters, digits, and special characters."""
    # Define character sets
    lowercase = string.ascii_lowercase
    uppercase = string.ascii_uppercase
    digits = string.digits
    special = '!@#$%^&*()-_=+'
    
    # Ensure at least one of each character type
    password_parts = [
        random.choice(lowercase),
        random.choice(uppercase),
        random.choice(digits),
        random.choice(special)
    ]
    
    # Generate remaining characters
    remaining = ''.join(random.choices(
        lowercase + uppercase + digits + special,
        k=length - 4  # Subtract 4 for the fixed characters above
    ))
    
    # Combine and shuffle
    password = password_parts + list(remaining)
    random.shuffle(password)
    return ''.join(password)

# Configure upload folder and allowed extensions
UPLOAD_FOLDER = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'uploads')
ALLOWED_EXTENSIONS = {'pdf', 'doc', 'docx', 'txt'}
MAX_CONTENT_LENGTH = 16 * 1024 * 1024  # 16MB max file size

# Ensure upload folder exists
os.makedirs(UPLOAD_FOLDER, exist_ok=True)

# Configure Flask app
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = MAX_CONTENT_LENGTH
app.config['ALLOWED_EXTENSIONS'] = ALLOWED_EXTENSIONS

# Configure CORS with more permissive settings for development
# Allow all origins in development - restrict this in production
ALLOWED_ORIGINS = [
    'http://localhost',
    'http://127.0.0.1',
    'https://qkaaoeismqnhjyikgkme.supabase.co',
    'https://*.supabase.co',
    'https://*.supabase.in',
    'https://*.supabase.com'
]

# Configure CORS with the allowed origins
cors = CORS(
    app,
    resources={
        r"/*": {
            "origins": ALLOWED_ORIGINS,
            "methods": ["GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"],
            "allow_headers": ["Content-Type", "Authorization", "X-Requested-With", "Accept", "Origin"],
            "supports_credentials": True,
            "expose_headers": ["Content-Type", "Authorization", "X-Total-Count"],
            "max_age": 600  # 10 minutes
        }
    },
    supports_credentials=True
)

# Add CORS headers to all responses
@app.after_request
def add_cors_headers(response):
    # Only add CORS headers if the request has an Origin header
    origin = request.headers.get('Origin')
    if origin and any(origin.startswith(allowed) for allowed in ALLOWED_ORIGINS):
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-Requested-With, Accept, Origin'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS, PATCH'
        response.headers['Access-Control-Expose-Headers'] = 'Content-Type, Authorization, X-Total-Count'
    
    # Add security headers
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    # Handle preflight requests
    if request.method == 'OPTIONS':
        response.status_code = 200
    
    return response

# Supabase Configuration
SUPABASE_URL = os.getenv('SUPABASE_URL')
SUPABASE_KEY = os.getenv('SUPABASE_KEY')

if not SUPABASE_URL or not SUPABASE_KEY:
    raise ValueError("Missing Supabase configuration. Please check your .env file.")

# Initialize Supabase client
supabase = create_client(SUPABASE_URL, SUPABASE_KEY)

# Authentication middleware
def supabase_auth_required(fn):
    @wraps(fn)
    def wrapper(*args, **kwargs):
        auth_header = request.headers.get('Authorization')
        if not auth_header or not auth_header.startswith('Bearer '):
            return jsonify({"message": "Missing or invalid authorization header"}), 401
            
        token = auth_header.split(' ')[1]
        try:
            # Verify the token with Supabase
            user = supabase.auth.get_user(token)
            if not user:
                return jsonify({"message": "Invalid or expired token"}), 401
                
            # Add user info to the request context
            request.user = user
            return fn(*args, **kwargs)
            
        except Exception as e:
            return jsonify({
                "message": "Authentication failed",
                "error": str(e)
            }), 401
    return wrapper

# Configure CORS with more permissive settings for development
# Add CORS headers to all responses
@app.after_request
def add_cors_headers(response):
    # Get the origin from the request
    origin = request.headers.get('Origin', '')
    
    # Only set CORS headers if the origin is in the allowed list
    if origin in ALLOWED_ORIGINS:
        response.headers['Access-Control-Allow-Origin'] = origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS, PATCH, HEAD'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization, X-Requested-With, Accept, Origin, X-Request-ID'
        response.headers['Access-Control-Expose-Headers'] = 'Content-Type, Authorization, X-Total-Count'
    
    # Add security headers
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'SAMEORIGIN'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    
    return response


# Configure Gemini AI
# Prefer environment variable for API key, fall back to existing value if present
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY') or "AIzaSyAa2PR4eg5I-xRYS8W0GpJ_VohHh659ANk"
if genai_available:
    try:
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel('gemini-pro')
    except Exception as e:
        print(f"[STARTUP] Failed to configure google.generativeai: {e}")
        genai_available = False
        model = None
else:
    model = None

# Mock database for demonstration
MOCK_DATABASE = {
    'students': [
        {
            'id': 1,
            'register_number': 'REG2024001',
            'full_name': 'John Doe',
            'email': 'john.doe@email.com',
            'phone': '+91 9876543210',
            'course': 'B.Tech CSE',
            'current_semester': 5,
            'admission_year': 2022,
            'quota_type': 'merit',
            'category': 'general',
            'hostel_required': True,
            'transport_required': False,
            'status': 'active',
            'father_name': 'Robert Doe',
            'mother_name': 'Mary Doe',
            'date_of_birth': '2003-05-15',
            'address': '123 Main St, Chennai',
            'first_graduate': True
        },
        {
            'id': 2,
            'register_number': 'REG2024002',
            'full_name': 'Jane Smith',
            'email': 'jane.smith@email.com',
            'phone': '+91 9876543211',
            'course': 'B.Tech ECE',
            'current_semester': 3,
            'admission_year': 2023,
            'quota_type': 'sports',
            'category': 'obc',
            'hostel_required': False,
            'transport_required': True,
            'status': 'active',
            'father_name': 'James Smith',
            'mother_name': 'Lisa Smith',
            'date_of_birth': '2004-08-22',
            'address': '456 Oak Ave, Bangalore',
            'first_graduate': False
        }
    ],
    'attendance': [
        {'id': 1, 'student_id': 1, 'subject': 'Computer Networks', 'date': '2025-01-05', 'status': 'present'},
        {'id': 2, 'student_id': 1, 'subject': 'Database Systems', 'date': '2025-01-05', 'status': 'absent'},
        {'id': 3, 'student_id': 2, 'subject': 'Digital Electronics', 'date': '2025-01-05', 'status': 'present'}
    ],
    'marks': [
        {'id': 1, 'student_id': 1, 'subject': 'Computer Networks', 'exam_type': 'IA1', 'marks_obtained': 85, 'max_marks': 100},
        {'id': 2, 'student_id': 1, 'subject': 'Database Systems', 'exam_type': 'IA1', 'marks_obtained': 78, 'max_marks': 100}
    ]
}

@app.route('/')
def home():
    return jsonify({"message": "Cube Arts and Engineering College API", "status": "running"})

@app.route('/api/health', methods=['GET', 'OPTIONS'])
def health():
    """Enhanced health check endpoint with detailed system information"""
    if request.method == 'OPTIONS':
        # Handle preflight request
        response = make_response()
        response.headers.add('Access-Control-Allow-Origin', '*')
        response.headers.add('Access-Control-Allow-Headers', '*')
        response.headers.add('Access-Control-Allow-Methods', 'GET, OPTIONS')
        return response
    
    # Check database connection
    db_status = 'unknown'
    try:
        supabase = get_supabase()
        # Simple query to check database connection
        result = supabase.table('students').select('*').limit(1).execute()
        db_status = 'connected' if result.data is not None else 'error'
    except Exception as e:
        db_status = f'error: {str(e)}'
    
    # Get system information
    import platform
    import psutil
    
    return jsonify({
        'status': 'ok',
        'timestamp': datetime.utcnow().isoformat(),
        'service': 'student-management-api',
        'version': '1.0.0',
        'environment': os.getenv('FLASK_ENV', 'development'),
        'python_version': platform.python_version(),
        'system': {
            'os': platform.system(),
            'release': platform.release(),
            'machine': platform.machine(),
            'processor': platform.processor(),
            'cpu_percent': psutil.cpu_percent(),
            'memory_percent': psutil.virtual_memory().percent,
            'disk_usage': psutil.disk_usage('/').percent
        },
        'database': {
            'status': db_status,
            'tables': ['students', 'courses', 'exams']  # Add more tables as needed
        },
        'endpoints': {
            'student_dashboard': '/api/student_dashboard/<student_id>',
            'health': '/api/health',
            'test': '/api/test'
        },
        'cors': {
            'allowed_origins': ALLOWED_ORIGINS,
            'supports_credentials': True
        }
    }), 200

# Basic API endpoints for testing
@app.route('/api/test', methods=['GET'])
def test():
    return jsonify({"message": "API is working", "timestamp": datetime.utcnow().isoformat()})

# Basic admission submission endpoint
@app.route('/api/admissions/submit', methods=['POST'])
def submit_application():
    try:
        data = request.get_json()

        # Generate application ID and register number
        application_id = f"APP{datetime.now().year}{uuid.uuid4().hex[:6].upper()}"
        year = datetime.now().year

        # Get the count of existing students to generate next register number
        if supabase:
            try:
                count_response = supabase.table('students').select('id', count='exact').execute()
                student_count = count_response.count if count_response.count else 0
                register_number = f"REG{year}{(student_count + 1):03d}"
            except:
                register_number = f"REG{year}001"
        else:
            register_number = f"REG{year}001"

        # Prepare student data for database
        student_data = {
            'register_number': register_number,
            'full_name': data.get('full_name'),
            'email': data.get('email'),
            'phone': data.get('phone'),
            'date_of_birth': data.get('date_of_birth'),
            'gender': data.get('gender'),
            'course_id': data.get('course_id'),
            'admission_year': year,
            'admission_date': datetime.now().date().isoformat(),
            'quota_type': data.get('quota_type', 'merit'),
            'category': data.get('category', 'general'),
            'father_name': data.get('father_name'),
            'mother_name': data.get('mother_name'),
            'permanent_address': data.get('permanent_address'),
            'current_address': data.get('current_address'),
            'city': data.get('city'),
            'state': data.get('state'),
            'pincode': data.get('pincode'),
            'tenth_percentage': data.get('tenth_percentage'),
            'tenth_board': data.get('tenth_board'),
            'twelfth_percentage': data.get('twelfth_percentage'),
            'twelfth_board': data.get('twelfth_board'),
            'entrance_exam_score': data.get('entrance_exam_score'),
            'entrance_exam_rank': data.get('entrance_exam_rank'),
            'hostel_required': data.get('hostel_required', False),
            'transport_required': data.get('transport_required', False),
            'first_graduate': data.get('first_graduate', False),
            'status': 'pending_approval'
        }

        # Insert into Supabase
        if supabase:
            try:
                response = supabase.table('students').insert(student_data).execute()
                if response.data:
                    return jsonify({
                        'success': True,
                        'message': 'Admission application submitted successfully',
                        'data': {
                            'application_id': application_id,
                            'register_number': register_number,
                            'status': 'submitted',
                            'student_data': response.data[0]
                        }
                    }), 201
            except Exception as e:
                print(f"Supabase insert error: {e}")

        # Fallback response if Supabase fails
        return jsonify({
            'success': True,
            'message': 'Admission application submitted successfully',
            'data': {
                'application_id': application_id,
                'register_number': register_number,
                'status': 'submitted',
                'student_data': student_data
            }
        }), 201

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Initialize in-memory storage for courses if not using Supabase
if not hasattr(app, 'courses'):
    app.courses = [
        {
            'id': 1,
            'name': 'Bachelor of Technology - Computer Science Engineering',
            'code': 'B.Tech CSE',
            'duration': '4 years',
            'description': 'Comprehensive program covering computer science fundamentals and advanced topics',
            'fee_per_semester': 60000,
            'department': {'name': 'Computer Science Engineering', 'code': 'CSE'}
        },
        {
            'id': 2,
            'name': 'Bachelor of Technology - Electronics and Communication Engineering',
            'code': 'B.Tech ECE',
            'duration': '4 years',
            'description': 'Focused on electronics and communication systems',
            'fee_per_semester': 55000,
            'department': {'name': 'Electronics and Communication Engineering', 'code': 'ECE'}
        },
        {
            'id': 3,
            'name': 'Bachelor of Technology - Mechanical Engineering',
            'code': 'B.Tech MECH',
            'duration': '4 years',
            'description': 'Covers mechanical systems and engineering principles',
            'fee_per_semester': 50000,
            'department': {'name': 'Mechanical Engineering', 'code': 'MECH'}
        }
    ]
    
    # Ensure all courses have the required fields
    for course in app.courses:
        course.setdefault('fee_per_semester', 0)
        if 'department' not in course:
            course['department'] = {'name': 'General', 'code': 'GEN'}

# Course management endpoints
# DISABLED: Using blueprint version in routes/academics.py instead
# @app.route('/api/academics/courses', methods=['GET', 'POST', 'OPTIONS'])
# @cross_origin()
def handle_courses_DISABLED():
    if request.method == 'GET':
        # Get all courses with optional filtering
        try:
            filters = request.args.to_dict()
            filtered_courses = app.courses.copy()
            
            # Apply filters if any
            if 'code' in filters:
                filtered_courses = [c for c in filtered_courses if c['code'] == filters['code']]
            if 'department' in filters:
                filtered_courses = [c for c in filtered_courses if c['department']['code'] == filters['department']]
            
            # Create response with proper JSON structure
            response = jsonify({
                'success': True,
                'data': filtered_courses
            })
            
            # Add CORS headers
            return response, 200
            
        except Exception as e:
            return jsonify({
                'success': False, 
                'error': str(e)
            }), 500
            
    elif request.method == 'POST':
        # Create a new course
        try:
            # Ensure we have JSON data
            if not request.is_json:
                response = jsonify({
                    'success': False,
                    'error': 'Content-Type must be application/json'
                })
                return response, 400
                
            data = request.get_json()
            
            # Validate required fields
            required_fields = ['name', 'code', 'duration', 'description']
            missing_fields = [field for field in required_fields if field not in data]
            
            if missing_fields:
                response = jsonify({
                    'success': False,
                    'error': f'Missing required fields: {', '.join(missing_fields)}'
                })
                return response, 400
            
            # Check if course code already exists
            if any(c['code'] == data['code'] for c in app.courses):
                response = jsonify({
                    'success': False,
                    'error': f'Course with code {data['code']} already exists'
                })
                return response, 400
            
            # Create new course with default values
            new_course = {
                'id': max(c['id'] for c in app.courses) + 1 if app.courses else 1,
                'name': data['name'].strip(),
                'code': data['code'].strip().upper(),
                'duration': data['duration'].strip(),
                'description': data['description'].strip(),
                'fee_per_semester': float(data.get('fee_per_semester', 0)),
                'department': data.get('department', {'name': 'General', 'code': 'GEN'})
            }
            
            app.courses.append(new_course)
            
            # Create success response
            response = jsonify({
                'success': True,
                'message': 'Course created successfully',
                'data': new_course
            })
            
            # Add CORS headers
            return response, 201
            
        except Exception as e:
            return jsonify({
                'success': False,
                'error': f'Server error: {str(e)}'
            }), 500

# DISABLED: Using blueprint version in routes/academics.py instead
# @app.route('/api/academics/courses/<int:course_id>', methods=['GET', 'PUT', 'DELETE'])
def handle_course_DISABLED(course_id):
    try:
        # Find the course
        course = next((c for c in app.courses if c['id'] == course_id), None)
        if not course:
            return jsonify({'success': False, 'error': 'Course not found'}), 404
            
        if request.method == 'GET':
            return jsonify({'success': True, 'data': course})
            
        elif request.method == 'PUT':
            # Update course
            data = request.get_json()
            
            # Update only provided fields
            for key, value in data.items():
                if key in course and key != 'id':  # Don't allow changing the ID
                    course[key] = value
            
            return jsonify({
                'success': True,
                'message': 'Course updated successfully',
                'data': course
            })
            
        elif request.method == 'DELETE':
            # Delete course
            app.courses = [c for c in app.courses if c['id'] != course_id]
            return jsonify({
                'success': True,
                'message': 'Course deleted successfully'
            })
            
    except Exception as e:
        return jsonify({'success': False, 'error': str(e)}), 500

# Backward compatibility
@app.route('/api/courses', methods=['GET'])
def get_courses():
    return jsonify({
        'success': True,
        'data': app.courses
    }), 200

# Basic auth endpoints
@app.route('/api/login', methods=['POST'])
def login():
    data = request.get_json()
    email = data.get('email')
    password = data.get('password')

    if not email or not password:
        return jsonify({"message": "Email and password are required"}), 400

    try:
        # Authenticate with Supabase
        response = supabase.auth.sign_in_with_password({"email": email, "password": password})
        
        if hasattr(response, 'error') and response.error:
            return jsonify({"message": "Invalid credentials", "error": response.error.message}), 401
            
        user = response.user
        
        # Get the session
        session = supabase.auth.get_session()
        
        # Check if user exists in your students table
        student_data = supabase.table('students').select('*').eq('email', email).execute()
        
        if not student_data.data:
            return jsonify({"message": "No student found with this email"}), 404
            
        return jsonify({
            "message": "Login successful",
            "session": {
                "access_token": session.access_token,
                "refresh_token": session.refresh_token,
                "expires_at": session.expires_at,
                "expires_in": session.expires_in,
                "token_type": session.token_type
            },
            "user": {
                "id": user.id,
                "email": user.email,
                "role": student_data.data[0].get('role', 'student')
            }
        }), 200
            
    except Exception as e:
        app.logger.error(f"Login error: {str(e)}")
        return jsonify({"message": "Login failed", "error": str(e)}), 500
                supabase.table('profiles').delete().eq('id', auth_user_id).execute()
                if 'auth_user' in locals():
                    supabase.auth.admin.delete_user(auth_user_id)
            except Exception as cleanup_error:
                print(f"[ERROR] Failed to clean up after student creation error: {cleanup_error}")
            
            return jsonify({
                'success': False,
                'error': 'Failed to create student record',
                'details': error_msg,
                'traceback': traceback.format_exc()
            }), 500

        except Exception as cred_error:
            print(f"[ERROR] Credentials creation failed: {cred_error}")
            raise

        # Return success response with credentials
        response_data = {
            'success': True,
            'message': 'Student added successfully',
            'data': student,
            'register_number': register_number,
            'password': password,  # Return password for display
            'email': email,
            'username': username
        }
        print(f"[DEBUG] Returning success response")
        return jsonify(response_data), 201

    except Exception as e:
        import traceback
        error_msg = f"Error in add_student: {str(e)}"
        print(error_msg)
        print(traceback.format_exc())
        return jsonify({
            'success': False,
            'error': 'An error occurred while adding the student',
            'details': str(e) if str(e) != 'None' else 'Unknown error occurred'
        }), 500

# Hall Ticket Generation endpoint moved to students_bp

# Fees and Admission endpoints
@app.route('/api/students/<int:student_id>/fees', methods=['GET'])
@supabase_auth_required
def get_student_fees(student_id):
    try:
        # Try Supabase first
        if supabase:
            try:
                fees_response = supabase.table('fee_payments').select('''
                    *,
                    fee_structure (
                        *
                    )
                ''').eq('student_id', student_id).execute()

                if fees_response.data:
                    return jsonify({
                        'success': True,
                        'data': fees_response.data
                    }), 200
            except Exception as e:
                print(f"Supabase error: {e}")

        # Mock fees data
        mock_fees = {
            'fee_structure': {
                'tuition_fee': 50000,
                'lab_fee': 5000,
                'library_fee': 2000,
                'sports_fee': 1000,
                'development_fee': 3000,
                'exam_fee': 1000,
                'total_fee': 62000
            },
            'payments': [
                {
                    'id': 1,
                    'semester': 1,
                    'amount_paid': 62000,
                    'payment_date': '2022-08-15',
                    'payment_method': 'online',
                    'transaction_id': 'TXN123456789',
                    'receipt_number': 'RCP001',
                    'status': 'completed'
                },
                {
                    'id': 2,
                    'semester': 2,
                    'amount_paid': 62000,
                    'payment_date': '2022-12-15',
                    'payment_method': 'online',
                    'transaction_id': 'TXN123456790',
                    'receipt_number': 'RCP002',
                    'status': 'completed'
                },
                {
                    'id': 3,
                    'semester': 3,
                    'amount_paid': 62000,
                    'payment_date': '2023-08-15',
                    'payment_method': 'online',
                    'transaction_id': 'TXN123456791',
                    'receipt_number': 'RCP003',
                    'status': 'completed'
                },
                {
                    'id': 4,
                    'semester': 4,
                    'amount_paid': 62000,
                    'payment_date': '2023-12-15',
                    'payment_method': 'online',
                    'transaction_id': 'TXN123456792',
                    'receipt_number': 'RCP004',
                    'status': 'completed'
                },
                {
                    'id': 5,
                    'semester': 5,
                    'amount_paid': 0,
                    'payment_date': None,
                    'payment_method': None,
                    'transaction_id': None,
                    'receipt_number': None,
                    'status': 'pending'
                }
            ],
            'scholarships': [
                {
                    'id': 1,
                    'name': 'Merit Scholarship',
                    'amount': 10000,
                    'academic_year': '2024-25',
                    'status': 'approved'
                }
            ],
            'summary': {
                'total_fees': 310000,  # 5 semesters * 62000
                'total_paid': 248000,  # 4 semesters paid
                'pending_amount': 62000,  # Current semester
                'scholarship_amount': 10000
            }
        }

        return jsonify({
            'success': True,
            'data': mock_fees
        }), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Resume upload and AI feedback endpoint
@app.route('/api/students/<int:student_id>/resume', methods=['GET', 'POST'])
@supabase_auth_required
def handle_resume(student_id):
    if request.method == 'GET':
        try:
            # Check if the student has an uploaded resume
            upload_dir = app.config['UPLOAD_FOLDER']
            if not os.path.exists(upload_dir):
                return jsonify({'success': False, 'error': 'No uploads directory found'}), 404
                
            # Look for files that start with the student_id
            resume_files = [f for f in os.listdir(upload_dir) 
                          if f.startswith(f"{student_id}_") and 
                          f.lower().endswith(tuple(f".{ext}" for ext in app.config['ALLOWED_EXTENSIONS']))]
            
            if not resume_files:
                return jsonify({'success': False, 'error': 'No resume found for this student'}), 404
                
            # Get the most recent resume
            latest_resume = max(resume_files, key=lambda x: os.path.getmtime(os.path.join(upload_dir, x)))
            
            return jsonify({
                'success': True,
                'resume_url': f"/uploads/{latest_resume}",
                'filename': latest_resume,
                'uploaded_at': os.path.getmtime(os.path.join(upload_dir, latest_resume))
            })
            
        except Exception as e:
            print(f"Error retrieving resume: {str(e)}")
            return jsonify({'success': False, 'error': str(e)}), 500
    
    # Existing POST method implementation
    elif request.method == 'POST':
        try:
            print("Received resume upload request")
            print(f"Request headers: {request.headers}")
            print(f"Request files: {request.files}")
            
            # Check if the post request has the file part
            if 'resume' not in request.files:
                print("No file part in request")
                return jsonify({'success': False, 'error': 'No file part'}), 400
                
            file = request.files['resume']
            print(f"Received file: {file.filename}")
            
            # If user does not select file, browser may submit an empty part without filename
            if file.filename == '':
                print("No selected file")
                return jsonify({'success': False, 'error': 'No selected file'}), 400
                
            if not allowed_file(file.filename):
                print(f"File type not allowed: {file.filename}")
                return jsonify({'success': False, 'error': 'File type not allowed'}), 400
                
            # Generate unique filename
            filename = secure_filename(file.filename)
            unique_filename = f"{student_id}_{int(time.time())}_{filename}"
            filepath = os.path.join(app.config['UPLOAD_FOLDER'], unique_filename)
            
            # Ensure upload directory exists
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            try:
                # Save the file
                print(f"Saving file to: {filepath}")
                file.save(filepath)
                print("File saved successfully")
                
                # For now, skip AI analysis and just return success
                return jsonify({
                    'success': True,
                    'message': 'File uploaded successfully',
                    'file_path': f"/uploads/{unique_filename}",
                    'filename': unique_filename
                }), 200
                
            except Exception as e:
                print(f"Error saving file: {str(e)}")
                if os.path.exists(filepath):
                    try:
                        os.remove(filepath)
                    except:
                        pass
                return jsonify({'success': False, 'error': f'Error saving file: {str(e)}'}), 500
                
        except Exception as e:
            print(f"Error in upload_resume: {str(e)}")
            return jsonify({'success': False, 'error': 'An unexpected error occurred'}), 500

# Add this helper function if not already present
def allowed_file(filename):
    return '.' in filename and filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

# Student settings endpoints
@app.route('/api/students/<int:student_id>/settings', methods=['GET'])
def get_student_settings(student_id):
    try:
        # Mock settings data
        settings = {
            'notifications': {
                'email_notifications': True,
                'sms_notifications': True,
                'push_notifications': True,
                'academic_alerts': True,
                'fee_reminders': True,
                'exam_notifications': True
            },
            'privacy': {
                'profile_visibility': 'private',
                'contact_sharing': False,
                'academic_sharing': False
            },
            'preferences': {
                'language': 'english',
                'theme': 'light',
                'dashboard_layout': 'grid',
                'date_format': 'DD/MM/YYYY'
            },
            'security': {
                'two_factor_enabled': False,
                'login_alerts': True,
                'session_timeout': 30
            }
        }

        return jsonify({
            'success': True,
            'data': settings
        }), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/students/<int:student_id>/settings', methods=['PUT'])
def update_student_settings(student_id):
    try:
        data = request.get_json()

        # Mock settings update
        updated_settings = {
            **data,
            'updated_at': datetime.now().isoformat()
        }

        return jsonify({
            'success': True,
            'message': 'Settings updated successfully',
            'data': updated_settings
        }), 200

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Clubs endpoints
@app.route('/api/clubs', methods=['GET', 'POST'])
@cross_origin(origins=ALLOWED_ORIGINS, supports_credentials=True)
def handle_clubs():
    if request.method == 'GET':
        try:
            print("Attempting to fetch clubs from Supabase...")
            # Get all clubs from Supabase
            response = supabase.table('clubs').select('*').execute()
            print(f"Supabase response: {response}")
            
            # Check if response has data attribute
            if hasattr(response, 'data'):
                print(f"Found {len(response.data)} clubs")
                return jsonify({
                    'success': True,
                    'data': response.data
                }), 200
            else:
                print("No data attribute in response")
                return jsonify({
                    'success': True,
                    'data': []
                }), 200
                
        except Exception as e:
            import traceback
            error_msg = f"Error fetching clubs: {str(e)}\n{traceback.format_exc()}"
            print(error_msg)
            return jsonify({
                'success': False,
                'message': 'Failed to fetch clubs',
                'error': str(e)
            }), 500
    
    elif request.method == 'POST':
        try:
            data = request.get_json()
            # Add new club to Supabase
            response = supabase.table('clubs').insert(data).execute()
            return jsonify({
                'success': True,
                'data': response.data[0] if hasattr(response, 'data') and response.data else {}
            }), 201
        except Exception as e:
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500

@app.route('/api/clubs/<club_id>', methods=['GET', 'PUT', 'DELETE'])
@cross_origin(origins=ALLOWED_ORIGINS, supports_credentials=True)
def handle_club(club_id):
    if request.method == 'GET':
        try:
            # Get single club by ID
            response = supabase.table('clubs').select('*').eq('id', club_id).execute()
            if not response.data:
                return jsonify({'success': False, 'message': 'Club not found'}), 404
            return jsonify({'success': True, 'data': response.data[0]})
        except Exception as e:
            return jsonify({'success': False, 'message': str(e)}), 500
    
    elif request.method == 'PUT':
        try:
            data = request.get_json()
            # Update club in Supabase
            response = supabase.table('clubs').update(data).eq('id', club_id).execute()
            if not response.data:
                return jsonify({'success': False, 'message': 'Club not found'}), 404
            return jsonify({'success': True, 'data': response.data[0]})
        except Exception as e:
            return jsonify({'success': False, 'message': str(e)}), 500
    
    elif request.method == 'DELETE':
        try:
            # Delete club from Supabase
            response = supabase.table('clubs').delete().eq('id', club_id).execute()
            if not response.data:
                return jsonify({'success': False, 'message': 'Club not found'}), 404
            return jsonify({'success': True, 'message': 'Club deleted successfully'})
        except Exception as e:
            return jsonify({'success': False, 'message': str(e)}), 500

@app.route('/api/clubs/<club_id>/members', methods=['GET'])
@cross_origin(origins=ALLOWED_ORIGINS, supports_credentials=True)
def get_club_members(club_id):
    try:
        # Get club members with student information
        response = supabase.table('club_members').select('''
            *,
            students (
                register_number,
                profiles!students_user_id_fkey (
                    full_name,
                    email
                )
            )
        ''').eq('club_id', club_id).execute()

        if response.data:
            # Process the data to match expected format
            processed_members = []
            for member in response.data:
                processed_member = {
                    'id': member['id'],
                    'club_id': member['club_id'],
                    'student_id': member['student_id'],
                    'role': member['role'],
                    'status': member['status'],
                    'joined_at': member['joined_at'],
                    'name': member['students']['profiles']['full_name'] if member['students'] and member['students']['profiles'] else f"Student {member['student_id']}",
                    'email': member['students']['profiles']['email'] if member['students'] and member['students']['profiles'] else '',
                    'register_number': member['students']['register_number'] if member['students'] else '',
                    'is_faculty': False
                }
                processed_members.append(processed_member)

            return jsonify({
                'success': True,
                'data': processed_members
            })
        else:
            return jsonify({
                'success': True,
                'data': []
            })

    except Exception as e:
        print(f"Error fetching club members: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

@app.route('/api/clubs/<club_id>/members/<member_id>/role', methods=['PUT'])
@cross_origin(origins=ALLOWED_ORIGINS, supports_credentials=True)
def update_club_member_role(club_id, member_id):
    try:
        data = request.get_json()
        new_role = data.get('role')

        if not new_role:
            return jsonify({'success': False, 'message': 'Role is required'}), 400

        # Update member role in Supabase
        response = supabase.table('club_members').update({
            'role': new_role,
            'updated_at': datetime.now().isoformat()
        }).eq('id', member_id).eq('club_id', club_id).execute()

        if response.data:
            return jsonify({
                'success': True,
                'data': response.data[0]
            })
        else:
            return jsonify({'success': False, 'message': 'Member not found'}), 404

    except Exception as e:
        print(f"Error updating club member role: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

@app.route('/api/clubs/<club_id>/members/<member_id>', methods=['DELETE'])
@cross_origin(origins=ALLOWED_ORIGINS, supports_credentials=True)
def remove_club_member(club_id, member_id):
    try:
        # Delete member from Supabase
        response = supabase.table('club_members').delete().eq('id', member_id).eq('club_id', club_id).execute()

        if response.data:
            return jsonify({
                'success': True,
                'message': 'Member removed successfully'
            })
        else:
            return jsonify({'success': False, 'message': 'Member not found'}), 404

    except Exception as e:
        print(f"Error removing club member: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500

@app.route('/api/clubs/<club_id>/members/invite', methods=['POST'])
@cross_origin(origins=ALLOWED_ORIGINS, supports_credentials=True)
def invite_club_member(club_id):
    try:
        data = request.get_json()
        email = data.get('email')
        role = data.get('role', 'member')

        if not email:
            return jsonify({'success': False, 'message': 'Email is required'}), 400

        # Find the student by email through their profile
        profile_response = supabase.table('profiles').select('id').eq('email', email).execute()

        student_id = None
        if profile_response.data:
            # Find the student record associated with this profile
            student_response = supabase.table('students').select('uuid_id').eq('user_id', profile_response.data[0]['id']).execute()
            if student_response.data:
                student_id = student_response.data[0]['uuid_id']

        # Create or update club membership
        member_data = {
            'club_id': club_id,
            'student_id': student_id,
            'email': student_id if student_id else email,  # Only store email if student doesn't exist yet
            'role': role,
            'status': 'active' if student_id else 'pending',
            'joined_at': datetime.now().isoformat()
        }

        response = supabase.table('club_members').upsert(member_data, {
            'onConflict': 'club_id,student_id',
            'ignoreDuplicates': False
        }).execute()

        if response.data:
            return jsonify({
                'success': True,
                'data': response.data[0],
                'message': student_id if student_id else 'Invitation sent successfully'
            })
        else:
            return jsonify({'success': False, 'message': 'Failed to invite member'}), 500

    except Exception as e:
        print(f"Error inviting club member: {str(e)}")
        return jsonify({
            'success': False,
            'message': str(e)
        }), 500


# =====================================================
# UTILITY ENDPOINTS - AUTH USER CLEANUP
# =====================================================

@app.route('/api/admin/cleanup_orphaned_auth_users', methods=['POST', 'GET'])
@cross_origin()
def cleanup_orphaned_auth_users():
    """
    Clean up orphaned auth users (users in auth.users without corresponding student records).

    Query Parameters:
        - dry_run: If 'true', only list orphaned users without deleting (default: true)
        - email: Specific email to delete (optional)
    """
    try:
        dry_run = request.args.get('dry_run', 'true').lower() == 'true'
        specific_email = request.args.get('email')

        # If specific email is provided, delete only that user
        if specific_email:
            print(f"Attempting to delete auth user with email: {specific_email}")

            # Get all auth users and find the one with matching email
            auth_response = supabase.auth.admin.list_users()

            if not hasattr(auth_response, 'users') or not auth_response.users:
                return jsonify({
                    'success': False,
                    'error': 'No auth users found'
                }), 404

            user_to_delete = None
            for user in auth_response.users:
                if user.email and user.email.lower() == specific_email.lower():
                    user_to_delete = user
                    break

            if not user_to_delete:
                return jsonify({
                    'success': False,
                    'error': f'No auth user found with email: {specific_email}'
                }), 404

            # Delete the user
            try:
                supabase.auth.admin.delete_user(user_to_delete.id)
                return jsonify({
                    'success': True,
                    'message': f'Successfully deleted auth user: {specific_email}',
                    'deleted_user': {
                        'id': user_to_delete.id,
                        'email': user_to_delete.email
                    }
                }), 200
            except Exception as delete_error:
                return jsonify({
                    'success': False,
                    'error': f'Failed to delete auth user: {str(delete_error)}'
                }), 500

        # Otherwise, find all orphaned users
        print("Fetching all auth users...")
        auth_response = supabase.auth.admin.list_users()

        if not hasattr(auth_response, 'users') or not auth_response.users:
            return jsonify({
                'success': True,
                'message': 'No auth users found',
                'orphaned_users': []
            }), 200

        print(f"Found {len(auth_response.users)} auth users")

        # Get all students
        print("Fetching all students...")
        students_response = supabase.table('students').select('id, email, full_name').execute()
        student_emails = {student['email'].lower() for student in students_response.data if student.get('email')}
        student_ids = {str(student['id']) for student in students_response.data if student.get('id')}

        print(f"Found {len(students_response.data)} students")

        # Find orphaned users
        orphaned_users = []
        for user in auth_response.users:
            user_email = user.email.lower() if user.email else None
            user_role = user.user_metadata.get('role') if user.user_metadata else None

            # Only check student users
            if user_role == 'student':
                # Check if user exists in students table by email or id
                if user_email not in student_emails and str(user.id) not in student_ids:
                    orphaned_users.append({
                        'id': str(user.id),
                        'email': user.email,
                        'created_at': str(user.created_at),
                        'role': user_role
                    })

        if not orphaned_users:
            return jsonify({
                'success': True,
                'message': 'No orphaned auth users found',
                'orphaned_users': []
            }), 200

        # If dry run, just return the list
        if dry_run:
            return jsonify({
                'success': True,
                'message': f'Found {len(orphaned_users)} orphaned auth users (dry run - not deleted)',
                'orphaned_users': orphaned_users,
                'note': 'To actually delete these users, call this endpoint with ?dry_run=false'
            }), 200

        # Delete orphaned users
        deleted_count = 0
        failed_count = 0
        errors = []

        for user in orphaned_users:
            try:
                supabase.auth.admin.delete_user(user['id'])
                deleted_count += 1
                print(f"Deleted orphaned auth user: {user['email']}")
            except Exception as delete_error:
                failed_count += 1
                error_msg = f"Failed to delete {user['email']}: {str(delete_error)}"
                errors.append(error_msg)
                print(error_msg)

        return jsonify({
            'success': True,
            'message': f'Cleanup complete. Deleted: {deleted_count}, Failed: {failed_count}',
            'deleted_count': deleted_count,
            'failed_count': failed_count,
            'errors': errors if errors else None
        }), 200

    except Exception as e:
        print(f"Error in cleanup_orphaned_auth_users: {e}")
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


def register_blueprints():
    """Register all blueprints with the Flask application."""
    # Import blueprints here to avoid circular imports
    from routes.auth import auth_bp
    from routes.admin import admin_bp
    from routes.students import students_bp
    from routes.faculty import faculty_bp
    from routes.admissions import admissions_bp
    from routes.academics import academics_bp
    from routes.analytics import analytics_bp
    from routes.attendance import attendance_bp
    from routes.fees import fees_bp
    from routes.notifications import notifications_bp
    from routes.resume_analytics import resume_analytics_bp
    from routes.upgraded_system import upgraded_bp
    from routes.student_dashboard import student_dashboard_bp
    from routes.crud_apis import crud_bp
    from routes.career_roadmap import career_roadmap_bp
    from routes.career_courses import bp as career_courses_bp
    from routes.internships import bp as internships_bp
    from routes.exams import exams_bp
    
    # Register blueprints with proper URL prefixes
    # Note: Order matters - more specific routes should be registered first
    app.register_blueprint(auth_bp, url_prefix='/api/auth')  # Auth routes first
    app.register_blueprint(career_courses_bp, url_prefix='/api')  # Career courses routes
    app.register_blueprint(admin_bp, url_prefix='/api/admin')
    app.register_blueprint(students_bp, url_prefix='/api/students')
    app.register_blueprint(faculty_bp, url_prefix='/api/faculty')
    app.register_blueprint(admissions_bp, url_prefix='/api/admissions')
    app.register_blueprint(academics_bp, url_prefix='/api/academics')
    app.register_blueprint(analytics_bp, url_prefix='/api/analytics')
    app.register_blueprint(student_dashboard_bp, url_prefix='/api/student_dashboard')
    app.register_blueprint(career_roadmap_bp, url_prefix='/api/roadmap')
    app.register_blueprint(resume_analytics_bp, url_prefix='/api/resume')

    # General API routes (register these last to avoid route conflicts)
    app.register_blueprint(internships_bp, url_prefix='/api/internships')
    app.register_blueprint(exams_bp, url_prefix='/api')
    app.register_blueprint(attendance_bp, url_prefix='/api')
    app.register_blueprint(fees_bp, url_prefix='/api')
    app.register_blueprint(notifications_bp, url_prefix='/api')
    app.register_blueprint(upgraded_bp, url_prefix='/api')
    app.register_blueprint(crud_bp, url_prefix='/api')
    
    print("All blueprints registered successfully")

@app.route('/api/test', methods=['GET'])
def test_endpoint():
    return jsonify({
        'success': True,
        'message': 'API is working!',
        'time': datetime.now().isoformat(),
        'endpoints': {
            'student_dashboard': '/api/student_dashboard/<student_id>',
            'health': '/health',
            'test': '/api/test'
        }
    })

def list_routes(app):
    """List all registered routes"""
    output = []
    for rule in app.url_map.iter_rules():
        methods = ','.join(rule.methods)
        line = f"{rule.endpoint:50s} {methods:20s} {rule}"
        output.append(line)
    return sorted(output)

if __name__ == '__main__':
    print("\n" + "="*70)
    print("Starting Cube Arts and Engineering College API...")
    print("="*70)
    
    # Register blueprints before running the app
    try:
        print("\nRegistering blueprints...")
        register_blueprints()
        print(" Successfully registered all blueprints")
        
        # List all registered routes
        print("\nRegistered routes:")
        print("-" * 70)
        for route in list_routes(app):
            print(route)
            
    except Exception as e:
        print(f"\n Error registering blueprints: {e}")
        import traceback
        traceback.print_exc()
        exit(1)
    
    print("\n" + "="*70)
    print("API will be available at: http://localhost")
    print("Health check: http://localhost/health")
    print("Test endpoint: http://localhost/api/test")
    print("Student dashboard test: http://localhost/api/student_dashboard/test")
    print("Student dashboard example: http://localhost/api/student_dashboard/1")
    print("="*70 + "\n")
    
    # Run the app
    app.run(debug=True, host='0.0.0.0', port=5001, use_reloader=False)
